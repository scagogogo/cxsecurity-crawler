package cmd

import (
	"fmt"
	"os"
	"strings"

	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/jedib0t/go-pretty/v6/text"
	"github.com/spf13/cobra"
	"golang.org/x/term"

	"github.com/scagogogo/cxsecurity-crawler/pkg/crawler"
	"github.com/scagogogo/cxsecurity-crawler/pkg/model"
)

var (
	exploitOutputFile string
	exploitFields     string
	exploitIds        []string
	exploitSilent     bool
)

var exploitCmd = &cobra.Command{
	Use:   "exploit",
	Short: "爬取漏洞列表",
	Long:  `爬取CXSecurity网站的漏洞列表，并将结果保存为JSON格式`,
	Run: func(cmd *cobra.Command, args []string) {
		// 创建爬虫实例
		c := crawler.NewCrawler()

		// 执行爬取
		if len(exploitIds) > 0 {
			for _, id := range exploitIds {
				result, err := c.CrawlExploit(id, exploitOutputFile, exploitFields)
				if err != nil {
					fmt.Printf("爬取失败: %v\n", err)
					continue
				}

				// 只有在非静默模式下才输出结果
				if !exploitSilent {
					printExploitResult(result, exploitOutputFile)
				}
			}
		} else {
			result, err := c.CrawlExploit("", exploitOutputFile, exploitFields)
			if err != nil {
				fmt.Printf("爬取失败: %v\n", err)
				return
			}

			// 只有在非静默模式下才输出结果
			if !exploitSilent {
				printExploitResult(result, exploitOutputFile)
			}
		}
	},
}

// printExploitResult 根据结果类型格式化输出
func printExploitResult(result interface{}, outputPath string) {
	// 判断结果类型
	switch v := result.(type) {
	case *model.Vulnerability:
		// 获取终端宽度
		width, _, err := term.GetSize(int(os.Stdout.Fd()))
		if err != nil {
			// 如果获取失败，使用默认宽度
			width = 80
		}

		// 计算边框和内容宽度
		borderWidth := width - 2              // 两侧各减1个字符给边框
		titlePadding := (borderWidth - 8) / 2 // "漏洞详情"是4个汉字(8个字符宽度)，两侧填充

		// 构建顶部边框
		topBorder := "┏" + strings.Repeat("━", borderWidth) + "┓"
		titleLine := "┃" + strings.Repeat(" ", titlePadding) + "漏洞详情" + strings.Repeat(" ", borderWidth-titlePadding-8) + "┃"
		middleBorder := "┣" + strings.Repeat("━", borderWidth) + "┫"
		bottomBorder := "┗" + strings.Repeat("━", borderWidth) + "┛"

		// 显示表头
		fmt.Println()
		fmt.Println(topBorder)
		fmt.Println(titleLine)
		fmt.Println(middleBorder)

		// 获取ID（如果有）
		id := "未知"
		if v.ID != "" {
			id = v.ID
		} else if v.URL != "" && strings.Contains(v.URL, "WLB-") {
			idx := strings.Index(v.URL, "WLB-")
			id = v.URL[idx:]
		}

		// 格式化风险级别并上色
		riskLevel := v.RiskLevel
		switch strings.ToLower(riskLevel) {
		case "high":
			riskLevel = text.Colors{text.FgRed, text.Bold}.Sprint(riskLevel)
		case "med.", "medium":
			riskLevel = text.Colors{text.FgYellow, text.Bold}.Sprint(riskLevel)
		case "low":
			riskLevel = text.Colors{text.FgGreen, text.Bold}.Sprint(riskLevel)
		}

		// 格式化日期
		date := "未知"
		if !v.Date.IsZero() {
			date = v.Date.Format("2006-01-02")
		}

		// 计算内容区域宽度
		contentWidth := borderWidth - 2 // 左右各减1个字符的padding

		// 构建输出行的函数 - 修复布局问题
		printLine := func(label string, value string, color ...text.Color) {
			// 先处理标签
			labelText := text.Colors{text.Bold}.Sprint(label)
			labelDisplayWidth := stringDisplayWidth(label)

			// 先获取原始文本的显示宽度（在应用颜色之前）
			valueDisplayWidth := stringDisplayWidth(value)

			// 如果有指定颜色，应用到value
			valueText := value
			if len(color) > 0 {
				valueText = text.Colors(color).Sprint(value)
			}

			// 计算所需填充宽度 (2是": "的宽度)
			padding := contentWidth - labelDisplayWidth - 2 - valueDisplayWidth
			if padding < 0 {
				padding = 0
			}

			// 输出行，确保右边框对齐
			fmt.Printf("┃ %s: %s%s ┃\n", labelText, valueText, strings.Repeat(" ", padding))
		}

		// 输出详细信息
		printLine("漏洞ID", id, text.FgHiCyan)
		printLine("漏洞标题", v.Title)
		printLine("风险级别", riskLevel) // 已经着色
		printLine("发布日期", date)

		// 输出CVE编号（如果有）
		if v.CVE != "" {
			printLine("CVE编号", v.CVE, text.FgHiYellow)
		}

		// 输出CWE编号（如果有）
		if v.CWE != "" {
			printLine("CWE编号", v.CWE, text.FgHiYellow)
		}

		// 输出漏洞位置信息
		locationInfo := []string{}
		if v.IsRemote {
			locationInfo = append(locationInfo, "远程")
		}
		if v.IsLocal {
			locationInfo = append(locationInfo, "本地")
		}
		if len(locationInfo) > 0 {
			printLine("漏洞位置", strings.Join(locationInfo, ", "), text.FgHiGreen)
		}

		// 输出其他标签（如果有）
		if len(v.Tags) > 0 {
			printLine("其他标签", strings.Join(v.Tags, ", "), text.FgHiGreen)
		}

		printLine("作者", v.Author, text.FgHiMagenta)

		// 添加原始URL链接行
		if v.URL != "" {
			printLine("详情链接", v.URL, text.FgBlue)
		}

		// 输出底部边框
		fmt.Println(bottomBorder)

	case *model.VulnerabilityList:
		// 使用go-pretty创建美观的表格
		t := table.NewWriter()
		t.SetOutputMirror(os.Stdout)

		// 设置表格样式
		t.SetStyle(table.StyleRounded)

		// 获取终端宽度
		width, _, err := term.GetSize(int(os.Stdout.Fd()))
		if err != nil {
			// 如果获取失败，使用默认宽度
			width = 120
		}

		// 动态计算各列宽度
		// 终端宽度减去表格边框和列分隔符所占用的空间（大约是每列2个字符和表边框4个字符）
		availableWidth := width - (4 + 2*7) // 7列: ID、日期、风险、CVE、CWE、位置、标题、作者

		// 根据内容特点分配各列宽度占比
		idRatio := 0.13     // ID列 - 约13%
		dateRatio := 0.08   // 日期列 - 约8%
		riskRatio := 0.07   // 风险列 - 约7%
		cveRatio := 0.12    // CVE列 - 约12%
		cweRatio := 0.07    // CWE列 - 约7%
		locRatio := 0.08    // 位置列 - 约8%
		titleRatio := 0.30  // 标题列 - 约30%
		authorRatio := 0.15 // 作者列 - 约15%

		// 计算各列实际宽度（最小保证有合理的字符数）
		idWidth := max(15, int(float64(availableWidth)*idRatio))
		dateWidth := max(10, int(float64(availableWidth)*dateRatio))
		riskWidth := max(6, int(float64(availableWidth)*riskRatio))
		cveWidth := max(14, int(float64(availableWidth)*cveRatio))
		cweWidth := max(8, int(float64(availableWidth)*cweRatio))
		locWidth := max(8, int(float64(availableWidth)*locRatio))
		titleWidth := max(25, int(float64(availableWidth)*titleRatio))
		authorWidth := max(12, int(float64(availableWidth)*authorRatio))

		// 设置表头
		t.AppendHeader(table.Row{"ID", "日期", "风险", "CVE", "CWE", "位置", "标题", "作者"})

		// 设置表头样式 - 深色背景
		t.SetColumnConfigs([]table.ColumnConfig{
			{Number: 1, Align: text.AlignCenter, AlignHeader: text.AlignCenter, Colors: text.Colors{text.FgHiCyan}, ColorsHeader: text.Colors{text.BgBlack, text.FgHiWhite, text.Bold}, WidthMax: idWidth},
			{Number: 2, Align: text.AlignCenter, AlignHeader: text.AlignCenter, ColorsHeader: text.Colors{text.BgBlack, text.FgHiWhite, text.Bold}, WidthMax: dateWidth},
			{Number: 3, Align: text.AlignCenter, AlignHeader: text.AlignCenter, ColorsHeader: text.Colors{text.BgBlack, text.FgHiWhite, text.Bold}, WidthMax: riskWidth},
			{Number: 4, Align: text.AlignCenter, AlignHeader: text.AlignCenter, Colors: text.Colors{text.FgHiYellow}, ColorsHeader: text.Colors{text.BgBlack, text.FgHiWhite, text.Bold}, WidthMax: cveWidth},
			{Number: 5, Align: text.AlignCenter, AlignHeader: text.AlignCenter, Colors: text.Colors{text.FgHiYellow}, ColorsHeader: text.Colors{text.BgBlack, text.FgHiWhite, text.Bold}, WidthMax: cweWidth},
			{Number: 6, Align: text.AlignCenter, AlignHeader: text.AlignCenter, Colors: text.Colors{text.FgHiGreen}, ColorsHeader: text.Colors{text.BgBlack, text.FgHiWhite, text.Bold}, WidthMax: locWidth},
			{Number: 7, AlignHeader: text.AlignCenter, Colors: text.Colors{text.FgHiWhite}, ColorsHeader: text.Colors{text.BgBlack, text.FgHiWhite, text.Bold}, WidthMax: titleWidth},
			{Number: 8, AlignHeader: text.AlignCenter, Colors: text.Colors{text.FgHiMagenta}, ColorsHeader: text.Colors{text.BgBlack, text.FgHiWhite, text.Bold}, WidthMax: authorWidth},
		})

		// 添加数据行
		for _, item := range v.Items {
			// 从ID或URL中提取ID
			vulnID := "未知"
			if item.ID != "" {
				vulnID = item.ID
			} else if item.URL != "" {
				if idx := strings.Index(item.URL, "WLB-"); idx != -1 {
					vulnID = item.URL[idx:]
				}
			}

			// 日期格式化
			date := ""
			if !item.Date.IsZero() {
				date = item.Date.Format("2006-01-02")
			}

			// 标题可能很长，需要截断
			title := item.Title
			if len(title) > titleWidth-3 {
				// 截断标题部分，为省略号留出空间
				maxTitleLen := titleWidth - 6
				if maxTitleLen > 0 {
					if len(title) > maxTitleLen {
						title = title[:maxTitleLen] + "..."
					}
				}
			}

			// 作者名可能很长，需要截断
			author := item.Author
			if len(author) > authorWidth-3 {
				// 安全截断，确保不会越界
				maxAuthorLen := authorWidth - 6
				if maxAuthorLen > 0 {
					if len(author) > maxAuthorLen {
						author = author[:maxAuthorLen] + "..."
					}
				}
			}

			// CVE编号处理
			cve := item.CVE
			if len(cve) > cveWidth-3 {
				maxCveLen := cveWidth - 6
				if maxCveLen > 0 {
					if len(cve) > maxCveLen {
						cve = cve[:maxCveLen] + "..."
					}
				}
			}

			// CWE编号处理
			cwe := item.CWE
			if len(cwe) > cweWidth-3 {
				maxCweLen := cweWidth - 6
				if maxCweLen > 0 {
					if len(cwe) > maxCweLen {
						cwe = cwe[:maxCweLen] + "..."
					}
				}
			}

			// 位置信息处理
			location := ""
			if item.IsRemote && item.IsLocal {
				location = "远程/本地"
			} else if item.IsRemote {
				location = "远程"
			} else if item.IsLocal {
				location = "本地"
			}

			// 根据风险级别设置不同颜色
			riskLevel := item.RiskLevel
			var riskColor text.Colors

			switch strings.ToLower(riskLevel) {
			case "high":
				riskColor = text.Colors{text.FgRed, text.Bold}
			case "med.", "medium":
				riskColor = text.Colors{text.FgYellow, text.Bold}
			case "low":
				riskColor = text.Colors{text.FgGreen, text.Bold}
			default:
				riskColor = text.Colors{}
			}

			// 构建带颜色的风险等级文本
			coloredRisk := riskColor.Sprint(riskLevel)

			// 添加数据行
			t.AppendRow(table.Row{
				text.Colors{text.FgHiCyan}.Sprint(vulnID),
				date,
				coloredRisk,
				text.Colors{text.FgHiYellow}.Sprint(cve),
				text.Colors{text.FgHiYellow}.Sprint(cwe),
				text.Colors{text.FgHiGreen}.Sprint(location),
				title,
				text.Colors{text.FgHiMagenta}.Sprint(author),
			})
		}

		// 添加页码信息到表格底部
		t.AppendFooter(table.Row{
			fmt.Sprintf("总计: %d 条记录", len(v.Items)),
			"",
			"",
			"",
			"",
			"",
			fmt.Sprintf("页码: %d/%d", v.CurrentPage, v.TotalPages),
			""})

		// 渲染表格
		fmt.Printf("\n爬取成功！\n")
		t.Render()
		fmt.Println()
	}

	if outputPath != "" {
		fmt.Printf("结果已保存到 %s\n", outputPath)
	}
}

// stringDisplayWidth 计算字符串在显示终端的宽度(考虑中文等宽字符)
func stringDisplayWidth(s string) int {
	width := 0
	for _, r := range s {
		if r >= 0x4E00 && r <= 0x9FFF || // 中文字符
			r >= 0x3000 && r <= 0x303F || // 中文符号
			r >= 0xFF00 && r <= 0xFFEF { // 全角ASCII、全角标点
			width += 2
		} else {
			width += 1
		}
	}
	return width
}

// max 返回两个整数中的较大值
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func init() {
	rootCmd.AddCommand(exploitCmd)

	// 添加标志
	exploitCmd.Flags().StringVarP(&exploitOutputFile, "output", "o", "exploit_result.json", "输出文件路径")
	exploitCmd.Flags().StringVarP(&exploitFields, "fields", "f", "all", "要输出的字段，用逗号分隔，或使用'all'获取所有字段")
	exploitCmd.Flags().StringArrayVarP(&exploitIds, "id", "i", []string{}, "要爬取的漏洞ID，例如：WLB-2024040035或简写为2024040035")
	exploitCmd.Flags().BoolVarP(&exploitSilent, "silent", "s", false, "静默模式，不输出到标准输出，适用于API调用")
}
