package cmd

import (
	"fmt"
	"os"
	"strings"

	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/jedib0t/go-pretty/v6/text"
	"github.com/scagogogo/cxsecurity-crawler/pkg/crawler"
	"github.com/scagogogo/cxsecurity-crawler/pkg/model"
	"github.com/spf13/cobra"
	"golang.org/x/term"
)

var (
	exploitOutputFile string
	exploitFields     string
	exploitIds        []string
	exploitSilent     bool
)

var exploitCmd = &cobra.Command{
	Use:   "exploit",
	Short: "爬取漏洞列表",
	Long:  `爬取CXSecurity网站的漏洞列表，并将结果保存为JSON格式`,
	Run: func(cmd *cobra.Command, args []string) {
		// 创建爬虫实例
		c := crawler.NewCrawler()

		// 执行爬取
		if len(exploitIds) > 0 {
			for _, id := range exploitIds {
				result, err := c.CrawlExploit(id, exploitOutputFile, exploitFields)
				if err != nil {
					fmt.Printf("爬取失败: %v\n", err)
					continue
				}

				// 只有在非静默模式下才输出结果
				if !exploitSilent {
					printExploitResult(result, exploitOutputFile)
				}
			}
		} else {
			result, err := c.CrawlExploit("", exploitOutputFile, exploitFields)
			if err != nil {
				fmt.Printf("爬取失败: %v\n", err)
				return
			}

			// 只有在非静默模式下才输出结果
			if !exploitSilent {
				printExploitResult(result, exploitOutputFile)
			}
		}
	},
}

// printExploitResult 根据结果类型格式化输出
func printExploitResult(result interface{}, outputPath string) {
	// 判断结果类型
	switch v := result.(type) {
	case *model.Vulnerability:
		// 漏洞详情的美观展示
		fmt.Println()
		fmt.Println("┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓")
		fmt.Println("┃                                 漏洞详情                                     ┃")
		fmt.Println("┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫")

		// 获取ID（如果有）
		id := "未知"
		if v.ID != "" {
			id = v.ID
		} else if v.URL != "" && strings.Contains(v.URL, "WLB-") {
			idx := strings.Index(v.URL, "WLB-")
			id = v.URL[idx:]
		}

		// 格式化风险级别并上色
		riskLevel := v.RiskLevel
		var coloredRisk string
		switch strings.ToLower(riskLevel) {
		case "high":
			coloredRisk = text.Colors{text.FgRed, text.Bold}.Sprint(riskLevel)
		case "med.", "medium":
			coloredRisk = text.Colors{text.FgYellow, text.Bold}.Sprint(riskLevel)
		case "low":
			coloredRisk = text.Colors{text.FgGreen, text.Bold}.Sprint(riskLevel)
		default:
			coloredRisk = riskLevel
		}

		// 格式化日期
		date := "未知"
		if !v.Date.IsZero() {
			date = v.Date.Format("2006-01-02")
		}

		// 输出详细信息
		fmt.Printf("┃ %s: %-70s ┃\n", text.Colors{text.Bold}.Sprint("漏洞ID"), text.Colors{text.FgHiCyan}.Sprint(id))
		fmt.Printf("┃ %s: %-70s ┃\n", text.Colors{text.Bold}.Sprint("漏洞标题"), v.Title)
		fmt.Printf("┃ %s: %-70s ┃\n", text.Colors{text.Bold}.Sprint("风险级别"), coloredRisk)
		fmt.Printf("┃ %s: %-70s ┃\n", text.Colors{text.Bold}.Sprint("发布日期"), date)

		// 标签信息
		tags := "无"
		if len(v.Tags) > 0 {
			tags = strings.Join(v.Tags, ", ")
		}
		fmt.Printf("┃ %s: %-70s ┃\n", text.Colors{text.Bold}.Sprint("漏洞标签"), text.Colors{text.FgHiGreen}.Sprint(tags))

		// 作者信息
		fmt.Printf("┃ %s: %-70s ┃\n", text.Colors{text.Bold}.Sprint("作者"), text.Colors{text.FgHiMagenta}.Sprint(v.Author))
		fmt.Println("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛")

	case *model.VulnerabilityList:
		// 使用go-pretty创建美观的表格
		t := table.NewWriter()
		t.SetOutputMirror(os.Stdout)

		// 设置表格样式
		t.SetStyle(table.StyleRounded)

		// 获取终端宽度
		width, _, err := term.GetSize(int(os.Stdout.Fd()))
		if err != nil {
			// 如果获取失败，使用默认宽度
			width = 120
		}

		// 动态计算各列宽度
		// 终端宽度减去表格边框和列分隔符所占用的空间（大约是每列2个字符和表边框4个字符）
		availableWidth := width - (4 + 2*5) // 5列: ID、日期、风险、标题、作者

		// 根据内容特点分配各列宽度占比
		idRatio := 0.15     // ID列 - 约15%
		dateRatio := 0.10   // 日期列 - 约10%
		riskRatio := 0.08   // 风险列 - 约8%
		titleRatio := 0.47  // 标题列 - 约47%
		authorRatio := 0.20 // 作者列 - 约20%

		// 计算各列实际宽度（最小保证有10个字符）
		idWidth := max(15, int(float64(availableWidth)*idRatio))
		dateWidth := max(12, int(float64(availableWidth)*dateRatio))
		riskWidth := max(8, int(float64(availableWidth)*riskRatio))
		titleWidth := max(25, int(float64(availableWidth)*titleRatio))
		authorWidth := max(15, int(float64(availableWidth)*authorRatio))

		// 设置表头
		t.AppendHeader(table.Row{"ID", "日期", "风险", "标题", "作者"})

		// 设置表头颜色和样式 - 使用更通用的颜色，避免深色/浅色系问题
		t.SetColumnConfigs([]table.ColumnConfig{
			{Number: 1, Align: text.AlignCenter, AlignHeader: text.AlignCenter, Colors: text.Colors{text.FgHiCyan}, ColorsHeader: text.Colors{text.Bold}, WidthMax: idWidth},
			{Number: 2, Align: text.AlignCenter, AlignHeader: text.AlignCenter, ColorsHeader: text.Colors{text.Bold}, WidthMax: dateWidth},
			{Number: 3, Align: text.AlignCenter, AlignHeader: text.AlignCenter, Colors: text.Colors{text.FgHiYellow}, ColorsHeader: text.Colors{text.Bold}, WidthMax: riskWidth},
			{Number: 4, AlignHeader: text.AlignCenter, Colors: text.Colors{text.FgHiWhite}, ColorsHeader: text.Colors{text.Bold}, WidthMax: titleWidth},
			{Number: 5, AlignHeader: text.AlignCenter, Colors: text.Colors{text.FgHiMagenta}, ColorsHeader: text.Colors{text.Bold}, WidthMax: authorWidth},
		})

		// 添加数据行
		for _, item := range v.Items {
			// 从ID或URL中提取ID
			vulnID := "未知"
			if item.ID != "" {
				vulnID = item.ID
			} else if item.URL != "" {
				if idx := strings.Index(item.URL, "WLB-"); idx != -1 {
					vulnID = item.URL[idx:]
				}
			}

			// 日期格式化
			date := "未知"
			if !item.Date.IsZero() {
				date = item.Date.Format("2006-01-02")
			}

			// 标题可能很长，需要截断
			title := item.Title
			if len(title) > titleWidth-3 {
				// 截断标题部分
				maxTitleLen := titleWidth - 6 // 为省略号留出空间
				if maxTitleLen > 0 {
					// 添加安全检查，确保不会超出字符串边界
					if maxTitleLen <= len(title) {
						title = title[:maxTitleLen] + "..."
					}
				}
			}

			// 作者名可能很长，需要截断
			author := item.Author
			if len(author) > authorWidth-3 {
				// 增加安全检查
				endPos := authorWidth - 6
				if endPos > len(author) {
					endPos = len(author)
				}
				author = author[:endPos] + "..."
			}

			// 根据风险级别设置不同颜色
			riskLevel := item.RiskLevel
			var riskRow table.Row

			// 添加数据行，根据风险等级着色
			switch strings.ToLower(riskLevel) {
			case "high":
				riskRow = table.Row{vulnID, date, text.Colors{text.FgRed, text.Bold}.Sprint(riskLevel), title, author}
			case "med.", "medium":
				riskRow = table.Row{vulnID, date, text.Colors{text.FgYellow, text.Bold}.Sprint(riskLevel), title, author}
			case "low":
				riskRow = table.Row{vulnID, date, text.Colors{text.FgGreen, text.Bold}.Sprint(riskLevel), title, author}
			default:
				riskRow = table.Row{vulnID, date, riskLevel, title, author}
			}
			t.AppendRow(riskRow)
		}

		// 添加页码信息到表格底部
		t.AppendFooter(table.Row{
			fmt.Sprintf("总计: %d 条记录", len(v.Items)),
			"",
			"",
			fmt.Sprintf("页码: %d/%d", v.CurrentPage, v.TotalPages),
			""})

		// 渲染表格
		fmt.Printf("\n爬取成功！\n")
		t.Render()
		fmt.Println()
	}

	if outputPath != "" {
		fmt.Printf("结果已保存到 %s\n", outputPath)
	}
}

// max 返回两个整数中的较大值
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func init() {
	rootCmd.AddCommand(exploitCmd)

	// 添加标志
	exploitCmd.Flags().StringVarP(&exploitOutputFile, "output", "o", "exploit_result.json", "输出文件路径")
	exploitCmd.Flags().StringVarP(&exploitFields, "fields", "f", "all", "要输出的字段，用逗号分隔，或使用'all'获取所有字段")
	exploitCmd.Flags().StringArrayVarP(&exploitIds, "id", "i", []string{}, "要爬取的漏洞ID，例如：WLB-2024040035或简写为2024040035")
	exploitCmd.Flags().BoolVarP(&exploitSilent, "silent", "s", false, "静默模式，不输出到标准输出，适用于API调用")
}
