package model

import (
	"encoding/json"
	"testing"
	"time"
)

func TestVulnerabilityJSON(t *testing.T) {
	// 创建一个用于测试的时间
	testTime, _ := time.Parse("2006-01-02", "2023-05-15")

	// 测试用例
	testCases := []struct {
		name          string
		vulnerability Vulnerability
		expected      string
		omitEmpty     bool
	}{
		{
			name: "完整的漏洞信息",
			vulnerability: Vulnerability{
				Date:      testTime,
				Title:     "测试漏洞标题",
				URL:       "https://example.com/vuln/123",
				RiskLevel: "High",
				Tags:      []string{"CVE", "Remote", "XSS"},
				Author:    "测试作者",
				AuthorURL: "https://example.com/author/test",
			},
			expected: `{"date":"2023-05-15T00:00:00Z","title":"测试漏洞标题","url":"https://example.com/vuln/123","risk_level":"High","tags":["CVE","Remote","XSS"],"author":"测试作者","author_url":"https://example.com/author/test"}`,
		},
		{
			name: "部分空字段的漏洞信息",
			vulnerability: Vulnerability{
				Date:      testTime,
				Title:     "测试漏洞标题",
				URL:       "https://example.com/vuln/123",
				RiskLevel: "High",
				// Tags为空
				Author: "测试作者",
				// AuthorURL为空
			},
			expected: `{"date":"2023-05-15T00:00:00Z","title":"测试漏洞标题","url":"https://example.com/vuln/123","risk_level":"High","author":"测试作者"}`,
		},
		{
			name: "最小漏洞信息",
			vulnerability: Vulnerability{
				Title: "仅标题漏洞",
				// 其他字段都为空
			},
			expected: `{"title":"仅标题漏洞"}`,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// 序列化为JSON
			bytes, err := json.Marshal(tc.vulnerability)
			if err != nil {
				t.Fatalf("序列化失败: %v", err)
			}

			// 验证结果
			actual := string(bytes)
			if actual != tc.expected {
				t.Errorf("期望JSON: %s, 实际JSON: %s", tc.expected, actual)
			}

			// 尝试反序列化
			var decoded Vulnerability
			if err := json.Unmarshal(bytes, &decoded); err != nil {
				t.Fatalf("反序列化失败: %v", err)
			}

			// 验证标题等基本字段是否一致
			if decoded.Title != tc.vulnerability.Title {
				t.Errorf("期望标题: %s, 实际标题: %s", tc.vulnerability.Title, decoded.Title)
			}
		})
	}
}

func TestVulnerabilityListJSON(t *testing.T) {
	// 创建一个用于测试的时间
	testTime, _ := time.Parse("2006-01-02", "2023-05-15")

	// 创建测试数据
	vuln1 := Vulnerability{
		Date:      testTime,
		Title:     "测试漏洞1",
		URL:       "https://example.com/vuln/1",
		RiskLevel: "High",
		Tags:      []string{"CVE", "Remote"},
		Author:    "作者1",
	}

	vuln2 := Vulnerability{
		Date:      testTime.AddDate(0, 0, 1), // 第二天
		Title:     "测试漏洞2",
		URL:       "https://example.com/vuln/2",
		RiskLevel: "Medium",
		Tags:      []string{"CWE", "Local"},
		Author:    "作者2",
	}

	list := VulnerabilityList{
		Items:       []Vulnerability{vuln1, vuln2},
		CurrentPage: 1,
		TotalPages:  10,
	}

	// 序列化为JSON
	bytes, err := json.Marshal(list)
	if err != nil {
		t.Fatalf("序列化漏洞列表失败: %v", err)
	}

	// 反序列化回来
	var decodedList VulnerabilityList
	if err := json.Unmarshal(bytes, &decodedList); err != nil {
		t.Fatalf("反序列化漏洞列表失败: %v", err)
	}

	// 验证字段
	if decodedList.CurrentPage != 1 {
		t.Errorf("期望当前页码: 1, 实际: %d", decodedList.CurrentPage)
	}

	if decodedList.TotalPages != 10 {
		t.Errorf("期望总页数: 10, 实际: %d", decodedList.TotalPages)
	}

	if len(decodedList.Items) != 2 {
		t.Fatalf("期望漏洞条目数: 2, 实际: %d", len(decodedList.Items))
	}

	// 验证第一个漏洞条目
	if decodedList.Items[0].Title != "测试漏洞1" {
		t.Errorf("期望第一个漏洞标题: 测试漏洞1, 实际: %s", decodedList.Items[0].Title)
	}

	// 验证第二个漏洞条目
	if decodedList.Items[1].RiskLevel != "Medium" {
		t.Errorf("期望第二个漏洞风险级别: Medium, 实际: %s", decodedList.Items[1].RiskLevel)
	}
}
